# Инструкции по тестированию и записи сетевого трафика

## Содержание
1. [Тестирование в одной локальной сети](#тестирование-в-одной-локальной-сети)
2. [Тестирование с одним NAT](#тестирование-с-одним-nat)
3. [Тестирование с двумя NAT](#тестирование-с-двумя-nat)
4. [Запись сетевого трафика](#запись-сетевого-трафика)
5. [Анализ трафика](#анализ-трафика)

---

## Тестирование в одной локальной сети

### Схема

```
PC1 (192.168.1.10) ←→ Switch ←→ PC2 (192.168.1.20)
                    ←→ STUN Server (192.168.1.100)
```

### Шаги

1. **Запустите STUN сервер на одном из компьютеров:**
   ```bash
   go run *.go -mode=server -port=3478
   ```

2. **Запустите первый клиент:**
   ```bash
   go run *.go -mode=client -stun=192.168.1.100:3478 -peer=alice -target=bob
   ```

3. **Запустите второй клиент (в другом терминале или на другом компьютере):**
   ```bash
   go run *.go -mode=client -stun=192.168.1.100:3478 -peer=bob -target=alice
   ```

### Ожидаемый результат

- Оба клиента должны успешно подключиться
- Сообщения должны передаваться напрямую
- В логах сервера должно быть видно, что используются локальные адреса

---

## Тестирование с одним NAT

### Схема

```
PC1 (192.168.1.10) ←→ NAT (203.0.113.1) ←→ Internet ←→ PC2 (198.51.100.1)
                                                          ←→ STUN Server (198.51.100.50)
```

### Настройка NAT устройства

**Используйте Docker образ `cn-alpine` или Linux машину с двумя интерфейсами:**

1. **Создайте сетевые интерфейсы:**
   ```bash
   # На NAT устройстве
   ip link add name lan type dummy
   ip link add name wan type dummy
   ip addr add 192.168.1.1/24 dev lan
   ip addr add 203.0.113.1/24 dev wan
   ```

2. **Настройте iptables для NAT:**
   ```bash
   # Включите IP forwarding
   echo 1 > /proc/sys/net/ipv4/ip_forward

   # Настройте MASQUERADE (для исходящих пакетов)
   iptables -t nat -A POSTROUTING -o wan -j MASQUERADE

   # Разрешите входящие пакеты для установленных соединений
   iptables -A INPUT -i wan -m state --state ESTABLISHED,RELATED -j ACCEPT

   # Блокируйте все остальные входящие пакеты
   iptables -A INPUT -i wan -j DROP
   ```

3. **Настройте маршрутизацию:**
   ```bash
   # На PC1 (за NAT)
   ip route add default via 192.168.1.1

   # На PC2 (в интернете)
   # Обычная маршрутизация
   ```

### Шаги тестирования

1. **Запустите STUN сервер на PC2 или отдельном сервере:**
   ```bash
   go run *.go -mode=server -port=3478
   ```

2. **Запустите клиент на PC1 (за NAT):**
   ```bash
   go run *.go -mode=client -stun=198.51.100.50:3478 -peer=alice -target=bob
   ```

3. **Запустите клиент на PC2 (без NAT):**
   ```bash
   go run *.go -mode=client -stun=198.51.100.50:3478 -peer=bob -target=alice
   ```

### Ожидаемый результат

- PC1 должен узнать свой внешний адрес (203.0.113.1:XXXX)
- PC2 должен использовать свой прямой адрес
- Соединение должно установиться
- PC1 может отправлять сообщения PC2 напрямую

---

## Тестирование с двумя NAT

### Схема

```
PC1 (192.168.1.10) ←→ NAT1 (203.0.113.1) ←→ Internet ←→ NAT2 (198.51.100.1) ←→ PC2 (192.168.2.10)
                                            ←→ STUN Server (198.51.100.50)
```

### Настройка обоих NAT устройств

**NAT1:**
```bash
# Интерфейсы
ip link add name lan1 type dummy
ip link add name wan1 type dummy
ip addr add 192.168.1.1/24 dev lan1
ip addr add 203.0.113.1/24 dev wan1

# NAT правила
echo 1 > /proc/sys/net/ipv4/ip_forward
iptables -t nat -A POSTROUTING -o wan1 -j MASQUERADE
iptables -A INPUT -i wan1 -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A INPUT -i wan1 -j DROP
```

**NAT2:**
```bash
# Интерфейсы
ip link add name lan2 type dummy
ip link add name wan2 type dummy
ip addr add 192.168.2.1/24 dev lan2
ip addr add 198.51.100.1/24 dev wan2

# NAT правила
echo 1 > /proc/sys/net/ipv4/ip_forward
iptables -t nat -A POSTROUTING -o wan2 -j MASQUERADE
iptables -A INPUT -i wan2 -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A INPUT -i wan2 -j DROP
```

### Шаги тестирования

**ВАЖНО:** Оба клиента должны запуститься примерно одновременно!

1. **Запустите STUN сервер:**
   ```bash
   go run *.go -mode=server -port=3478
   ```

2. **Подготовьте оба клиента и запустите их одновременно:**

   **Терминал 1 (PC1):**
   ```bash
   go run *.go -mode=client -stun=198.51.100.50:3478 -peer=alice -target=bob
   ```

   **Терминал 2 (PC2):**
   ```bash
   go run *.go -mode=client -stun=198.51.100.50:3478 -peer=bob -target=alice
   ```

   Или используйте скрипт для одновременного запуска:
   ```bash
   #!/bin/bash
   # Запуск обоих клиентов одновременно
   (go run *.go -mode=client -stun=198.51.100.50:3478 -peer=alice -target=bob &)
   sleep 1
   go run *.go -mode=client -stun=198.51.100.50:3478 -peer=bob -target=alice
   ```

### Ожидаемый результат

- Оба клиента должны узнать свои внешние адреса
- Оба должны получить адреса друг друга
- Hole punching должен успешно установить соединение
- Сообщения должны передаваться напрямую между клиентами

---

## Запись сетевого трафика

> Готовый пример можно найти в `dumps/lan_success.pcap`. Файл записан в LAN-сценарии и демонстрирует полный цикл: STUN → обмен адресами → взаимные hole punch пакеты.

### Использование tcpdump

#### Запись всего UDP трафика

```bash
# На устройстве между NAT (например, на Switch3 или маршрутизаторе)
sudo tcpdump -i eth0 -w p2p_traffic.pcap udp

# Запись с подробным выводом
sudo tcpdump -i eth0 -v -w p2p_traffic.pcap udp

# Запись с очень подробным выводом (включая содержимое пакетов)
sudo tcpdump -i eth0 -vvv -X -w p2p_traffic.pcap udp
```

#### Запись трафика между конкретными адресами

```bash
# Только трафик между двумя NAT устройствами
sudo tcpdump -i eth0 -w p2p_traffic.pcap \
    host 203.0.113.1 and host 198.51.100.1 and udp

# Только трафик к/от STUN сервера
sudo tcpdump -i eth0 -w p2p_traffic.pcap \
    host 198.51.100.50 and udp
```

#### Запись с фильтрацией по портам

```bash
# Только трафик на порт STUN сервера
sudo tcpdump -i eth0 -w p2p_traffic.pcap \
    udp port 3478

# Трафик между клиентами (исключая STUN сервер)
sudo tcpdump -i eth0 -w p2p_traffic.pcap \
    udp and not port 3478
```

#### Просмотр в реальном времени

```bash
# Простой просмотр
sudo tcpdump -i eth0 -v udp

# С отображением содержимого
sudo tcpdump -i eth0 -X udp

# Только определенные пакеты
sudo tcpdump -i eth0 -v 'udp and host 203.0.113.1'
```

### Использование Wireshark

1. **Запустите tcpdump для записи:**
   ```bash
   sudo tcpdump -i eth0 -w p2p_traffic.pcap udp
   ```

2. **Выполните тестирование соединения**

3. **Остановите запись (Ctrl+C)**

4. **Откройте файл в Wireshark:**
   ```bash
   wireshark p2p_traffic.pcap
   ```

5. **Используйте фильтры:**
   ```
   # Все UDP пакеты
   udp

   # Только трафик между клиентами
   udp and not port 3478

   # Только STUN трафик
   udp port 3478

   # Пакеты от конкретного хоста
   ip.src == 203.0.113.1

   # Пакеты к конкретному хосту
   ip.dst == 198.51.100.1
   ```

### Использование tshark (командная строка Wireshark)

```bash
# Анализ записанного файла
tshark -r p2p_traffic.pcap -Y "udp"

# Статистика по адресам
tshark -r p2p_traffic.pcap -q -z conv,udp

# Вывод пакетов с подробностями
tshark -r p2p_traffic.pcap -V udp
```

---

## Анализ трафика

### Что искать в трафике

#### 1. STUN запросы и ответы

**Запрос:**
```
Время: 0.000s
Источник: 192.168.1.10:XXXXX
Получатель: 198.51.100.50:3478
Протокол: UDP
Данные: [0x01]  (STUN_REQUEST)
```

**Ответ:**
```
Время: 0.001s
Источник: 198.51.100.50:3478
Получатель: 203.0.113.1:YYYYY (внешний адрес)
Протокол: UDP
Данные: [0x02] [IP] [Port]  (STUN_RESPONSE)
```

**Объяснение:**
- Клиент отправляет STUN запрос
- NAT преобразует адрес источника
- Сервер видит внешний адрес и возвращает его

#### 2. Регистрация на Rendezvous сервере

**Регистрация:**
```
Время: 0.500s
Источник: 203.0.113.1:YYYYY
Получатель: 198.51.100.50:3478
Протокол: UDP
Данные: [0x03] "alice\0bob"  (PEER_INFO_REQ)
```

**Готовность:**
```
Время: 1.000s
Источник: 203.0.113.1:YYYYY
Получатель: 198.51.100.50:3478
Протокол: UDP
Данные: [0x05] "alice\0[IP][Port]"  (PEER_READY)
```

**Объяснение:**
- Клиент регистрируется с ID "alice"
- Ищет пира "bob"
- Отправляет свой внешний адрес

#### 3. Обмен адресами

**От сервера к клиенту:**
```
Время: 1.100s
Источник: 198.51.100.50:3478
Получатель: 203.0.113.1:YYYYY
Протокол: UDP
Данные: [0x04] [198.51.100.1] [Port]  (PEER_INFO)
```

**Объяснение:**
- Сервер отправляет адрес целевого пира
- Клиент сохраняет адрес для последующего соединения

#### 4. Hole Punching пакеты

**Критически важно:** Пакеты должны идти **одновременно**!

```
Время: 1.500s
Источник: 203.0.113.1:YYYYY
Получатель: 198.51.100.1:ZZZZZ
Протокол: UDP
Данные: [0x07] "Hole punch 0 from alice"

Время: 1.500s (ОДНОВРЕМЕННО!)
Источник: 198.51.100.1:ZZZZZ
Получатель: 203.0.113.1:YYYYY
Протокол: UDP
Данные: [0x07] "Hole punch 0 from bob"
```

**Объяснение:**
- Оба клиента отправляют пакеты одновременно
- NAT устройства открывают порты для исходящих пакетов
- Пакеты проходят через открытые порты
- Соединение устанавливается

#### 5. Установленное P2P соединение

```
Время: 2.000s+
Источник: 203.0.113.1:YYYYY
Получатель: 198.51.100.1:ZZZZZ
Протокол: UDP
Данные: [0x07] "Привет!"

Время: 2.001s
Источник: 198.51.100.1:ZZZZZ
Получатель: 203.0.113.1:YYYYY
Протокол: UDP
Данные: [0x07] "Привет от bob!"
```

**Объяснение:**
- Прямое соединение установлено
- Сообщения передаются напрямую между клиентами
- STUN сервер больше не участвует в обмене данными

### Анализ временных меток

**Важные моменты для анализа:**

1. **Время между STUN запросом и ответом:**
   - Должно быть минимальным (< 10ms в локальной сети)
   - Показывает задержку сети

2. **Время между регистрацией и обменом адресов:**
   - Зависит от того, когда оба клиента зарегистрируются
   - Если оба клиента запущены одновременно, должно быть небольшим

3. **Время начала hole punching:**
   - Оба клиента должны начать примерно в одно время
   - Разница не должна превышать 1-2 секунды

4. **Время между первыми hole punch пакетами:**
   - Должно быть минимальным (желательно < 100ms)
   - Показывает, насколько хорошо синхронизированы клиенты

### Типичные проблемы и их признаки в трафике

#### Проблема 1: Клиенты не синхронизированы

**Признак:**
```
Время: 1.500s - Клиент A отправляет пакеты
Время: 5.000s - Клиент B отправляет пакеты (слишком поздно!)
```

**Решение:** Запустите клиентов одновременно

#### Проблема 2: NAT блокирует пакеты

**Признак:**
```
Время: 1.500s - Клиент A отправляет пакет B
Время: 1.501s - Пакет доходит до NAT B
Время: 1.502s - NAT B отбрасывает пакет (нет mapping)
```

**Решение:** Проверьте настройки iptables, убедитесь, что используется p2p-friendly NAT

#### Проблема 3: Клиенты используют разные порты

**Признак:**
```
Время: 1.500s - Клиент A отправляет на 198.51.100.1:54321
Время: 1.501s - Клиент B отправляет с 198.51.100.1:54322 (другой порт!)
```

**Решение:** Проверьте, что клиенты используют правильные адреса, полученные от сервера

---

## Примеры команд для анализа

### Статистика по пакетам

```bash
# Количество пакетов от каждого хоста
tshark -r p2p_traffic.pcap -q -z io,stat,1,"COUNT(ip.src) ip.src"

# Размер пакетов
tshark -r p2p_traffic.pcap -q -z io,stat,1,"SUM(ip.len) ip.len"
```

### Временной анализ

```bash
# Время между первыми пакетами от каждого клиента
tshark -r p2p_traffic.pcap -T fields -e frame.time_relative -e ip.src
```

### Фильтрация по типу сообщений

```bash
# Только STUN запросы (байт 0x01)
tshark -r p2p_traffic.pcap -Y "udp[0]==0x01"

# Только P2P сообщения (байт 0x07)
tshark -r p2p_traffic.pcap -Y "udp[0]==0x07"
```

---

## Рекомендации

1. **Записывайте трафик на устройстве между NAT**, а не на самих клиентах
2. **Используйте фильтры** для уменьшения размера файлов
3. **Анализируйте временные метки** для понимания синхронизации
4. **Проверяйте содержимое пакетов** для отладки протокола
5. **Сохраняйте записи** для последующего анализа и объяснения

---

**Удачи в тестировании!**



