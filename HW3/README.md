# Домашняя работа 3: P2P приложение с обходом NAT

## Оглавление
1. [Введение](#введение)
2. [Основные термины и концепции](#основные-термины-и-концепции)
3. [Алгоритм NAT Hole Punching](#алгоритм-nat-hole-punching)
4. [Архитектура решения](#архитектура-решения)
5. [Сборка и запуск](#сборка-и-запуск)
6. [Тестирование](#тестирование)
7. [Запись сетевого трафика](#запись-сетевого-трафика)
8. [Подробное объяснение кода](#подробное-объяснение-кода)

---

## Введение

Эта домашняя работа реализует P2P (peer-to-peer) приложение, которое позволяет двум клиентам устанавливать прямое UDP соединение, даже когда они находятся за NAT (Network Address Translation) устройствами. Это достигается с помощью техники **NAT Hole Punching** (пробивание NAT).

> **Что нового (24.11.2025):**
> - Клиенты всегда слушают на явном IPv4-сокете и формируют список кандидатов (внешний + локальные адреса). Это устранило проблемы связи в одной локальной сети и при работе за общим NAT.
> - Добавлен готовый дамп `dumps/lan_success.pcap` и подробное описание того, что видно в трафике.
> - Обновлены разделы про тестирование и запись трафика (см. ниже), чтобы проще было воспроизвести и проверить лабу.

### Что такое P2P?

**P2P (Peer-to-Peer)** - это архитектура сети, где узлы (пиры) напрямую взаимодействуют друг с другом без центрального сервера. В отличие от клиент-серверной архитектуры, где все общение идет через сервер, в P2P каждый узел может быть и клиентом, и сервером одновременно.

**Преимущества P2P:**
- Нет единой точки отказа
- Меньше нагрузка на сервер
- Прямое соединение между клиентами (низкая задержка)
- Масштабируемость

**Проблема P2P:**
- Большинство устройств находятся за NAT
- NAT блокирует входящие соединения
- Клиенты не знают своих внешних адресов

---

## Основные термины и концепции

### 1. NAT (Network Address Translation)

**NAT** - это механизм преобразования сетевых адресов, который позволяет множеству устройств в локальной сети использовать один публичный IP-адрес для выхода в интернет.

#### Как работает NAT:

```
Локальная сеть (192.168.1.0/24):
├── Компьютер A: 192.168.1.10:5000
├── Компьютер B: 192.168.1.20:5000
└── NAT устройство: 192.168.1.1 (LAN) / 203.0.113.1 (WAN)

Интернет (публичные адреса):
└── Сервер: 198.51.100.1:80
```

**Процесс:**
1. Компьютер A (192.168.1.10:5000) отправляет пакет серверу (198.51.100.1:80)
2. NAT перехватывает пакет и заменяет:
   - **Источник:** 192.168.1.10:5000 → 203.0.113.1:12345
   - NAT создает таблицу трансляции (mapping):
     ```
     192.168.1.10:5000 ↔ 203.0.113.1:12345
     ```
3. Сервер получает пакет от 203.0.113.1:12345
4. Когда сервер отвечает на 203.0.113.1:12345, NAT:
   - Находит запись в таблице
   - Заменяет получателя на 192.168.1.10:5000
   - Передает пакет в локальную сеть

#### Типы NAT:

1. **Full Cone NAT (Полный конус)**
   - Самый простой тип
   - Любой внешний хост может отправить пакет на открытый порт
   - Порт остается открытым определенное время

2. **Restricted Cone NAT (Ограниченный конус)**
   - Порт открыт только для IP-адреса, с которым был установлен исходящий контакт
   - Любой порт этого IP может отправить пакет

3. **Port Restricted Cone NAT (Порт-ограниченный конус)**
   - Порт открыт только для конкретной пары (IP, порт)
   - Только тот хост, с которым был контакт, может отправить пакет

4. **Symmetric NAT (Симметричный)**
   - Самый сложный тип
   - Для каждого внешнего адреса создается новый порт
   - Самый сложный для hole punching

#### Почему NAT блокирует входящие соединения?

**Без NAT:**
```
Клиент A → Сервер: "Привет, я здесь: 192.168.1.10:5000"
Клиент B → Сервер: "Привет, я здесь: 192.168.1.20:5000"
Сервер → Клиент A: "Клиент B находится по адресу 192.168.1.20:5000"
Клиент A → Клиент B: "Привет!" ✅ Работает!
```

**С NAT:**
```
Клиент A → NAT → Сервер: "Привет, я здесь: 192.168.1.10:5000"
Сервер видит: 203.0.113.1:12345 (внешний адрес)
Клиент B → NAT → Сервер: "Привет, я здесь: 192.168.1.20:5000"
Сервер видит: 203.0.113.2:54321 (внешний адрес)

Сервер → Клиент A: "Клиент B находится по адресу 203.0.113.2:54321"
Клиент A → NAT → Клиент B: Пытается отправить на 203.0.113.2:54321
❌ NAT B не знает, что делать с этим пакетом!
   Таблица трансляции пуста, пакет отбрасывается.
```

---

### 2. STUN (Session Traversal Utilities for NAT)

**STUN** - это протокол, который помогает клиентам определить:
- Их внешний (публичный) IP-адрес
- Порт, который NAT присвоил для исходящих соединений
- Тип NAT устройства

#### Как работает STUN:

```
1. Клиент → STUN сервер: "Какой мой внешний адрес?"
2. STUN сервер → Клиент: "Твой внешний адрес: 203.0.113.1:12345"
   (STUN сервер видит адрес клиента в заголовке пакета)
3. Клиент узнает свой внешний адрес ✅
```

**В нашем коде:**
```go
// Клиент отправляет STUN запрос
request := []byte{STUN_REQUEST}
c.localConn.WriteToUDP(request, c.stunServerAddr)

// STUN сервер отвечает с адресом клиента
response[0] = STUN_RESPONSE
copy(response[1:5], clientAddr.IP.To4())  // IP адрес
binary.BigEndian.PutUint16(response[5:7], uint16(clientAddr.Port))  // Порт
```

---

### 3. Rendezvous Server (Сервер рандеву)

**Rendezvous Server** - это центральный сервер, который помогает двум клиентам найти друг друга.

#### Зачем нужен Rendezvous Server?

1. **Обмен информацией о внешних адресах:**
   - Клиент A узнал свой внешний адрес через STUN: 203.0.113.1:12345
   - Клиент B узнал свой внешний адрес: 203.0.113.2:54321
   - Но они не знают адреса друг друга!

2. **Координация:**
   - Rendezvous сервер получает адреса обоих клиентов
   - Отправляет каждому клиенту адрес другого

**В нашем коде:**
```go
// Клиент регистрируется
peerInfo := &PeerInfo{
    ID:          peerID,
    LocalAddr:   clientAddr,      // Адрес, с которого пришел пакет
    ExternalAddr: externalAddr,    // Внешний адрес, который клиент узнал
}
```

---

### 4. NAT Hole Punching (Пробивание NAT)

**NAT Hole Punching** - это техника установления прямого P2P соединения между двумя клиентами, находящимися за NAT.

#### Принцип работы:

**Ключевая идея:** NAT открывает порт для исходящих соединений. Если два клиента отправят пакеты друг другу **одновременно**, они могут пройти через открытые порты!

```
Шаг 1: Оба клиента узнают внешние адреса друг друга через Rendezvous сервер
Шаг 2: Оба клиента ОДНОВРЕМЕННО начинают отправлять пакеты друг другу
Шаг 3: NAT устройства открывают порты для исходящих пакетов
Шаг 4: Пакеты от другого клиента проходят через открытые порты
Шаг 5: Прямое P2P соединение установлено! ✅
```

#### Временная диаграмма:

```
Время →
         │
Клиент A │  ┌─────────────────────────────────┐
         │  │ Отправка пакетов B               │
         │  └─────────────────────────────────┘
         │  ┌─────────────────────────────────┐
         │  │ Прием пакетов от B              │
         │  └─────────────────────────────────┘
         │
Клиент B │  ┌─────────────────────────────────┐
         │  │ Отправка пакетов A               │
         │  └─────────────────────────────────┘
         │  ┌─────────────────────────────────┐
         │  │ Прием пакетов от A              │
         │  └─────────────────────────────────┘
         │
         │  ⚡ КРИТИЧЕСКИ ВАЖНО: отправка и прием
         │    должны происходить ОДНОВРЕМЕННО!
```

---

## Алгоритм NAT Hole Punching

### Полный алгоритм (5 шагов):

#### Шаг 1: Определение внешнего адреса (STUN)

```go
func (c *P2PClient) discoverExternalAddress() error {
    // Отправляем STUN запрос
    request := []byte{STUN_REQUEST}
    c.localConn.WriteToUDP(request, c.stunServerAddr)

    // Получаем ответ с внешним адресом
    n, _, _ := c.localConn.ReadFromUDP(buffer)
    externalIP := net.IP(buffer[1:5])
    externalPort := binary.BigEndian.Uint16(buffer[5:7])

    c.externalAddr = &net.UDPAddr{IP: externalIP, Port: int(externalPort)}
}
```

**Что происходит:**
- Клиент отправляет пакет STUN серверу
- NAT преобразует адрес: `192.168.1.10:5000 → 203.0.113.1:12345`
- STUN сервер видит адрес `203.0.113.1:12345` и возвращает его клиенту
- Клиент теперь знает свой внешний адрес

#### Шаг 2: Регистрация на Rendezvous сервере

```go
func (c *P2PClient) registerWithRendezvous() error {
    message := append(PEER_INFO_REQ, []byte(c.peerID)...)
    message = append(message, 0)  // Разделитель
    message = append(message, []byte(c.targetPeerID)...)

    c.localConn.WriteToUDP(message, c.stunServerAddr)
}
```

**Что происходит:**
- Клиент регистрируется на сервере с ID `peerID`
- Указывает, что ищет пира с ID `targetPeerID`
- Сервер сохраняет локальный адрес клиента

#### Шаг 3: Отправка информации о готовности

```go
func (c *P2PClient) sendReady() error {
    message := append(PEER_READY, []byte(c.peerID)...)
    message = append(message, 0)
    message = append(message, c.externalAddr.IP.To4()...)
    message = append(message, portBytes...)

    c.localConn.WriteToUDP(message, c.stunServerAddr)
}
```

**Что происходит:**
- Клиент отправляет серверу свой внешний адрес
- Сервер сохраняет эту информацию
- Если оба клиента готовы, сервер обменивает их адреса

#### Шаг 4: Получение адреса целевого пира

```go
func (c *P2PClient) waitForPeerInfo() error {
    for {
        n, _, _ := c.localConn.ReadFromUDP(buffer)
        if buffer[0] == PEER_INFO {
            peerIP := net.IP(buffer[1:5])
            peerPort := binary.BigEndian.Uint16(buffer[5:7])
            c.peerAddr = &net.UDPAddr{IP: peerIP, Port: int(peerPort)}
            return nil
        }
    }
}
```

**Что происходит:**
- Клиент ждет сообщения от сервера
- Сервер отправляет адрес целевого пира
- Клиент сохраняет адрес для последующего соединения

#### Шаг 5: NAT Hole Punching

```go
func (c *P2PClient) performHolePunching() error {
    // Горутина для отправки пакетов
    go func() {
        for i := 0; i < 30; i++ {
            message := []byte{P2P_MESSAGE}
            message = append(message, []byte("Hole punch")...)
            c.localConn.WriteToUDP(message, c.peerAddr)
            time.Sleep(100 * time.Millisecond)
        }
    }()

    // Параллельно слушаем ответы
    for {
        n, addr, _ := c.localConn.ReadFromUDP(buffer)
        if addr.IP.Equal(c.peerAddr.IP) {
            c.connected = true
            return nil  // Соединение установлено!
        }
    }
}
```

**Что происходит:**
1. **Оба клиента одновременно** начинают отправлять пакеты друг другу
2. NAT устройства открывают порты для исходящих пакетов
3. Пакеты проходят через открытые порты
4. Клиенты получают пакеты друг от друга
5. Прямое P2P соединение установлено!

**Критически важно:**
- Отправка и прием должны происходить **параллельно**
- Оба клиента должны начать **одновременно**
- Пакеты должны отправляться **активно** (не ждать ответа)

---

## Архитектура решения

### Три сценария работы:

#### Сценарий 1: Оба клиента в одной локальной сети

```
PC1 (192.168.1.10) ←→ Switch ←→ PC2 (192.168.1.20)
```

**Как это работает:**
1. Оба клиента подключаются к STUN серверу
2. STUN сервер видит их локальные адреса: `192.168.1.10` и `192.168.1.20`
3. Сервер отправляет клиентам локальные адреса друг друга
4. Клиенты могут напрямую соединиться без NAT

**В коде:**
```go
// Если ExternalAddr не установлен, используем LocalAddr
if targetPeer.ExternalAddr == nil {
    s.sendPeerInfoLocal(peerID, targetPeer)
}
```

#### Сценарий 2: Один клиент за NAT, другой нет

```
PC1 (192.168.1.10) ←→ NAT (203.0.113.1) ←→ Internet ←→ PC2 (198.51.100.1)
```

**Как это работает:**
1. PC1 за NAT → внешний адрес: `203.0.113.1:12345`
2. PC2 без NAT → адрес: `198.51.100.1:5000`
3. Rendezvous сервер обменивает адреса
4. PC1 отправляет пакеты на `198.51.100.1:5000` (прямое соединение)
5. PC2 отправляет пакеты на `203.0.113.1:12345` (через NAT)

**В коде:**
```go
// Один имеет ExternalAddr, другой нет
if targetPeer.ExternalAddr != nil && peerInfo.ExternalAddr == nil {
    s.sendPeerInfo(peerID, targetPeer)  // PC1 получает внешний адрес PC2
    s.sendPeerInfoLocal(targetPeerID, peerInfo)  // PC2 получает локальный адрес PC1
}
```

#### Сценарий 3: Оба клиента за NAT

```
PC1 ←→ NAT1 (203.0.113.1) ←→ Internet ←→ NAT2 (198.51.100.1) ←→ PC2
```

**Как это работает:**
1. PC1 за NAT1 → внешний адрес: `203.0.113.1:12345`
2. PC2 за NAT2 → внешний адрес: `198.51.100.1:54321`
3. Rendezvous сервер обменивает внешние адреса
4. **Оба клиента одновременно** начинают отправлять пакеты:
   - PC1 → `198.51.100.1:54321`
   - PC2 → `203.0.113.1:12345`
5. NAT устройства открывают порты для исходящих пакетов
6. Пакеты проходят через открытые порты
7. Прямое P2P соединение установлено!

**В коде:**
```go
// Оба имеют ExternalAddr
if targetPeer.ExternalAddr != nil && peerInfo.ExternalAddr != nil {
    s.sendPeerInfo(peerID, targetPeer)
    s.sendPeerInfo(targetPeerID, peerInfo)
}
```

---

## Сборка и запуск

### Требования

- Go 1.21 или выше
- Доступ к сети (для тестирования)

### Сборка

```bash
cd HW3
go mod tidy
go build -o p2p-app *.go
```

### Запуск STUN/Rendezvous сервера

```bash
# На публичном сервере или хосте, доступном обоим клиентам
go run *.go -mode=server -port=3478
```

Или скомпилированная версия:
```bash
./p2p-app -mode=server -port=3478
```

**Вывод:**
```
STUN/Rendezvous Server listening on port 3478
Server will help clients discover their external addresses and connect peers
```

### Запуск клиентов

**Терминал 1 (Первый клиент):**
```bash
go run *.go -mode=client -stun=stun-server:3478 -peer=alice -target=bob
```

**Терминал 2 (Второй клиент):**
```bash
go run *.go -mode=client -stun=stun-server:3478 -peer=bob -target=alice
```

**Параметры:**
- `-mode=client`: режим клиента
- `-stun=host:port`: адрес STUN/Rendezvous сервера
- `-peer=ID`: ваш идентификатор (уникальный)
- `-target=ID`: идентификатор целевого пира

### Пример вывода клиента:

```
Local UDP address: 0.0.0.0:54321
Step 1: Discovering external address via STUN...
External address discovered: 203.0.113.1:12345
Step 2: Registering with rendezvous server...
Registered as peer alice, looking for peer bob
Step 3: Sending ready status...
Ready status sent
Step 4: Waiting for peer info from rendezvous server...
Peer info received: 198.51.100.1:54321
Step 5: Performing NAT hole punching...
Attempting to connect to peer at 198.51.100.1:54321
Starting simultaneous send/receive for hole punching...
→ Sent hole punch packet 0 to 198.51.100.1:54321
→ Sent hole punch packet 1 to 198.51.100.1:54321
...
✓ Received from peer 198.51.100.1:54321: Hole punch 5 from bob
✓ Connection established!

=== P2P Connection Established! ===
You can now send messages to your peer.
Type 'quit' to exit.

> Привет!
> [Peer 198.51.100.1:54321]: Привет от bob!
```

---

## Тестирование

### Тестирование в одной локальной сети

**Схема:**
```
PC1 (192.168.1.10) ←→ Switch ←→ PC2 (192.168.1.20)
                    ←→ STUN Server (192.168.1.100)
```

**Команды:**

**Терминал 1 (STUN сервер):**
```bash
go run *.go -mode=server -port=3478
```

**Терминал 2 (Клиент 1):**
```bash
go run *.go -mode=client -stun=192.168.1.100:3478 -peer=alice -target=bob
```

**Терминал 3 (Клиент 2):**
```bash
go run *.go -mode=client -stun=192.168.1.100:3478 -peer=bob -target=alice
```

### Тестирование с одним NAT

**Схема:**
```
PC1 (192.168.1.10) ←→ NAT (203.0.113.1) ←→ Internet ←→ PC2 (198.51.100.1)
                                                          ←→ STUN Server (198.51.100.50)
```

**Настройка NAT (iptables):**
```bash
# На устройстве NAT
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
iptables -A INPUT -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A INPUT -i eth0 -j DROP
```

### Тестирование с двумя NAT

**Схема:**
```
PC1 ←→ NAT1 (203.0.113.1) ←→ Internet ←→ NAT2 (198.51.100.1) ←→ PC2
                                            ←→ STUN Server (198.51.100.50)
```

**Важно:** Оба клиента должны запуститься примерно одновременно для успешного hole punching!

---

## Запись сетевого трафика

### Использование tcpdump

**На устройстве между NAT (например, Switch3):**

```bash
# Запись всего UDP трафика
sudo tcpdump -i eth0 -w p2p_traffic.pcap udp

# Или только трафик между конкретными адресами
sudo tcpdump -i eth0 -w p2p_traffic.pcap \
    host 203.0.113.1 and host 198.51.100.1 and udp

# Просмотр в реальном времени
sudo tcpdump -i eth0 -v udp
```

### Использование Wireshark

1. Откройте файл `p2p_traffic.pcap` в Wireshark
2. Фильтр: `udp and (ip.src == 203.0.113.1 or ip.dst == 203.0.113.1)`
3. Анализируйте пакеты

### Что искать в трафике:

1. **STUN запросы/ответы:**
   - Клиент → STUN сервер: `STUN_REQUEST`
   - STUN сервер → Клиент: `STUN_RESPONSE` с внешним адресом

2. **Регистрация на Rendezvous:**
   - Клиент → Сервер: `PEER_INFO_REQ`
   - Клиент → Сервер: `PEER_READY` с внешним адресом

3. **Обмен адресами:**
   - Сервер → Клиент: `PEER_INFO` с адресом целевого пира

4. **Hole punching пакеты:**
   - Клиент A → Клиент B: `P2P_MESSAGE` "Hole punch 0..."
   - Клиент B → Клиент A: `P2P_MESSAGE` "Hole punch 0..."
   - **Критично:** Пакеты должны идти **одновременно**!

5. **Установленное соединение:**
   - Клиент A ↔ Клиент B: Обычные P2P сообщения

### Объяснение происходящего в трафике

**Фаза 1: Discovery (Обнаружение)**
```
Время: 0.0s
PC1 → STUN: STUN_REQUEST
STUN → PC1: STUN_RESPONSE (203.0.113.1:12345)
PC2 → STUN: STUN_REQUEST
STUN → PC2: STUN_RESPONSE (198.51.100.1:54321)
```
**Объяснение:** Каждый клиент узнает свой внешний адрес.

**Фаза 2: Registration (Регистрация)**
```
Время: 0.5s
PC1 → STUN: PEER_INFO_REQ (alice, bob)
PC2 → STUN: PEER_INFO_REQ (bob, alice)
```
**Объяснение:** Клиенты регистрируются на сервере и указывают, кого ищут.

**Фаза 3: Exchange (Обмен)**
```
Время: 1.0s
PC1 → STUN: PEER_READY (alice, 203.0.113.1:12345)
PC2 → STUN: PEER_READY (bob, 198.51.100.1:54321)
STUN → PC1: PEER_INFO (198.51.100.1:54321)
STUN → PC2: PEER_INFO (203.0.113.1:12345)
```
**Объяснение:** Сервер обменивает внешние адреса клиентов.

**Фаза 4: Hole Punching (Пробивание)**
```
Время: 1.5s
PC1 → NAT1: Пакет на 198.51.100.1:54321
NAT1 открывает порт 12345 для исходящих пакетов
PC1 → Internet → NAT2: Пакет на 198.51.100.1:54321
NAT2 получает пакет, но не знает, что с ним делать ❌

Время: 1.5s (ОДНОВРЕМЕННО!)
PC2 → NAT2: Пакет на 203.0.113.1:12345
NAT2 открывает порт 54321 для исходящих пакетов
PC2 → Internet → NAT1: Пакет на 203.0.113.1:12345
NAT1 видит, что порт 12345 уже открыт для исходящих пакетов
NAT1 → PC1: Пакет от PC2 ✅
```

**Объяснение:**
- NAT устройства открывают порты для **исходящих** пакетов
- Если пакеты приходят **одновременно**, они могут пройти через открытые порты
- После первого успешного обмена пакетами, NAT устройства помнят это соединение
- Дальнейшие пакеты проходят без проблем

**Фаза 5: Established (Установлено)**
```
Время: 2.0s+
PC1 ↔ PC2: Прямые P2P сообщения
```
**Объяснение:** Прямое соединение установлено, дальнейшее общение идет напрямую.

### Готовый дамп и расшифровка

- **Файл:** `dumps/lan_success.pcap`
- **Сценарий:** оба клиента находятся в подсети `192.168.16.0/24`, сервер располагается на `192.168.16.100`.
- **Как открыть:** `wireshark dumps/lan_success.pcap` или `tcpdump -r dumps/lan_success.pcap -vv`.
- **Что вы увидите:**
  1. `STUN_REQUEST` от `192.168.16.2:40000` на сервер `192.168.16.100:3478`.
  2. `STUN_RESPONSE`, где сервер возвращает внешний адрес клиента.
  3. `P2P_MESSAGE` (hole punch) от клиента A (`192.168.16.2:40000`) к клиенту B (`192.168.16.3:50000`).
  4. Ответный `P2P_MESSAGE` от клиента B на клиента A.
- **Больше деталей:** в `dumps/README.md` есть пошаговая расшифровка пакетов и команды `tcpdump`, с помощью которых была сделана запись.

---

## Подробное объяснение кода

### Структура проекта

```
HW3/
├── stun_server.go    # STUN/Rendezvous сервер
├── p2p_client.go     # P2P клиент
├── go.mod            # Зависимости Go
└── README.md         # Этот файл
```

### stun_server.go

#### Константы протокола

```go
const (
    STUN_REQUEST     = 0x01  // Запрос на определение внешнего адреса
    STUN_RESPONSE    = 0x02  // Ответ с внешним адресом
    PEER_INFO_REQ    = 0x03  // Запрос на регистрацию пира
    PEER_INFO        = 0x04  // Информация о целевом пире
    PEER_READY       = 0x05  // Пир готов (узнал свой адрес)
    PEER_CONNECT     = 0x06  // Сообщение о подключении (для логирования)
)
```

**Объяснение:** Простой бинарный протокол. Первый байт - тип сообщения, остальное - данные.

#### Структура STUN сервера

```go
type STUNServer struct {
    port      int                    // Порт для прослушивания
    conn      *net.UDPConn           // UDP соединение
    peers     map[string]*PeerInfo   // Зарегистрированные пиры
    peerPairs map[string]string      // Связь между пирами (peerID → targetPeerID)
}

type PeerInfo struct {
    ID           string          // Идентификатор пира
    LocalAddr    *net.UDPAddr    // Локальный адрес (как видит сервер)
    ExternalAddr *net.UDPAddr    // Внешний адрес (который клиент узнал)
    LastSeen     time.Time       // Время последнего контакта
}
```

**Объяснение:**
- `LocalAddr` - адрес, с которого клиент отправил пакет (виден серверу)
- `ExternalAddr` - адрес, который клиент узнал через STUN (может быть тем же, что LocalAddr, если клиент не за NAT)

#### Обработка STUN запроса

```go
func (s *STUNServer) handleSTUNRequest(clientAddr *net.UDPAddr) {
    response := make([]byte, 1+4+2)
    response[0] = STUN_RESPONSE

    ip := clientAddr.IP.To4()
    copy(response[1:5], ip)
    binary.BigEndian.PutUint16(response[5:7], uint16(clientAddr.Port))

    s.conn.WriteToUDP(response, clientAddr)
}
```

**Объяснение:**
- Сервер получает пакет от клиента
- В заголовке UDP пакета есть адрес отправителя (`clientAddr`)
- Сервер возвращает этот адрес клиенту
- Клиент узнает свой внешний адрес (или локальный, если не за NAT)

#### Обработка регистрации пира

```go
func (s *STUNServer) handlePeerInfoRequest(clientAddr *net.UDPAddr, payload []byte) {
    peerID := string(parts[0])
    targetPeerID := string(parts[1])

    peerInfo := &PeerInfo{
        ID:          peerID,
        LocalAddr:   clientAddr,
        ExternalAddr: nil,  // Будет установлен позже
        LastSeen:    time.Now(),
    }
    s.peers[peerID] = peerInfo
    s.peerPairs[peerID] = targetPeerID
}
```

**Объяснение:**
- Клиент регистрируется с ID `peerID`
- Указывает, что ищет пира `targetPeerID`
- Сервер сохраняет локальный адрес клиента
- Если целевой пир уже зарегистрирован, отправляет информацию

#### Обмен адресами

```go
func (s *STUNServer) handlePeerReady(clientAddr *net.UDPAddr, payload []byte) {
    // Парсим внешний адрес, который клиент узнал
    peerInfo.ExternalAddr = externalAddr

    // Если целевой пир тоже готов, обмениваем адреса
    targetPeer, exists := s.peers[targetPeerID]
    if exists {
        if targetPeer.ExternalAddr != nil && peerInfo.ExternalAddr != nil {
            // Оба за NAT - обмениваем внешние адреса
            s.sendPeerInfo(peerID, targetPeer)
            s.sendPeerInfo(targetPeerID, peerInfo)
        } else if targetPeer.ExternalAddr == nil && peerInfo.ExternalAddr == nil {
            // Оба в одной сети - обмениваем локальные адреса
            s.sendPeerInfoLocal(peerID, targetPeer)
            s.sendPeerInfoLocal(targetPeerID, peerInfo)
        }
        // ... другие случаи
    }
}
```

**Объяснение:**
- Когда клиент готов (узнал свой адрес), сервер проверяет, готов ли целевой пир
- Если оба готовы, сервер обменивает их адреса
- Выбор адреса зависит от ситуации:
  - Оба за NAT → внешние адреса
  - Оба в одной сети → локальные адреса
  - Один за NAT, другой нет → внешний для одного, локальный для другого

### p2p_client.go

#### Структура P2P клиента

```go
type P2PClient struct {
    stunServerAddr *net.UDPAddr  // Адрес STUN/Rendezvous сервера
    peerID         string         // Идентификатор этого клиента
    targetPeerID   string         // Идентификатор целевого пира
    localConn      *net.UDPConn   // UDP соединение для общения
    externalAddr   *net.UDPAddr   // Внешний адрес (узнан через STUN)
    peerAddr       *net.UDPAddr   // Адрес целевого пира
    connected      bool           // Флаг установленного соединения
}
```

**Объяснение:**
- `localConn` - UDP сокет, через который идет все общение
- `externalAddr` - адрес, который клиент узнал через STUN
- `peerAddr` - адрес целевого пира (получен от сервера)

#### Создание UDP соединения

```go
func NewP2PClient(stunServer string, peerID string, targetPeerID string) (*P2PClient, error) {
    localConn, err := net.ListenUDP("udp", nil)
    // ...
}
```

**Объяснение:**
- `net.ListenUDP("udp", nil)` создает UDP сокет
- `nil` означает "любой доступный порт"
- Операционная система автоматически назначит свободный порт
- Этот порт будет использоваться для всех соединений

#### Алгоритм установления соединения

```go
func (c *P2PClient) Connect() error {
    // Шаг 1: Определяем внешний адрес
    c.discoverExternalAddress()

    // Шаг 2: Регистрируемся на сервере
    c.registerWithRendezvous()

    // Шаг 3: Отправляем информацию о готовности
    c.sendReady()

    // Шаг 4: Ждем информацию о целевом пире
    c.waitForPeerInfo()

    // Шаг 5: Выполняем NAT hole punching
    c.performHolePunching()

    // Шаг 6: Начинаем P2P общение
    c.startP2PCommunication()
}
```

**Объяснение:** Последовательность шагов, описанная выше.

#### Критическая часть: Hole Punching

```go
func (c *P2PClient) performHolePunching() error {
    // Горутина для отправки пакетов
    go func() {
        for i := 0; i < 30; i++ {
            message := []byte{P2P_MESSAGE}
            message = append(message, []byte("Hole punch")...)
            c.localConn.WriteToUDP(message, c.peerAddr)
            time.Sleep(100 * time.Millisecond)
        }
    }()

    // Параллельно слушаем ответы
    for {
        buffer := make([]byte, 1024)
        n, addr, err := c.localConn.ReadFromUDP(buffer)
        if addr.IP.Equal(c.peerAddr.IP) {
            c.connected = true
            return nil
        }
    }
}
```

**Объяснение:**
- **Горутина** отправляет пакеты асинхронно
- **Основной поток** слушает ответы
- Это позволяет отправлять и принимать **одновременно**
- Как только получен пакет от пира, соединение установлено

#### Почему это работает?

1. **NAT открывает порт для исходящих пакетов:**
   ```
   Клиент → NAT: Пакет на 198.51.100.1:54321
   NAT создает mapping: 192.168.1.10:5000 ↔ 203.0.113.1:12345
   NAT открывает порт 12345 для входящих пакетов от 198.51.100.1:54321
   ```

2. **Если пакеты приходят одновременно:**
   ```
   Время T:
   - Клиент A отправляет пакет B → NAT A открывает порт
   - Клиент B отправляет пакет A → NAT B открывает порт
   - Пакеты проходят через открытые порты ✅
   ```

3. **После первого успешного обмена:**
   ```
   NAT устройства помнят соединение в таблице трансляции
   Дальнейшие пакеты проходят без проблем
   ```

---

## Заключение

### Что мы реализовали:

1. ✅ **STUN сервер** - определение внешних адресов
2. ✅ **Rendezvous сервер** - обмен адресами между клиентами
3. ✅ **P2P клиент** - установление прямого соединения
4. ✅ **NAT Hole Punching** - пробивание NAT для прямого соединения
5. ✅ **Поддержка трех сценариев:**
   - Оба клиента в одной сети
   - Один клиент за NAT
   - Оба клиента за NAT

### Ключевые моменты для понимания:

1. **NAT блокирует входящие соединения**, но открывает порты для исходящих
2. **Hole punching работает**, если оба клиента отправляют пакеты одновременно
3. **STUN нужен** для определения внешних адресов
4. **Rendezvous сервер нужен** для обмена адресами (но не для передачи данных!)
5. **После установления соединения** клиенты общаются напрямую

### Как написать такое же приложение:

1. **Изучите основы UDP:**
   - `net.ListenUDP()` - создание UDP сокета
   - `conn.ReadFromUDP()` - чтение пакетов
   - `conn.WriteToUDP()` - отправка пакетов

2. **Реализуйте простой протокол:**
   - Первый байт - тип сообщения
   - Остальные байты - данные

3. **Создайте STUN сервер:**
   - Получает пакеты от клиентов
   - Возвращает адрес отправителя

4. **Реализуйте Rendezvous логику:**
   - Регистрация клиентов
   - Обмен адресами

5. **Критически важно для Hole Punching:**
   - Отправка и прием должны быть **параллельными**
   - Используйте горутины для одновременной отправки и приема
   - Оба клиента должны начать примерно одновременно

6. **Тестируйте:**
   - Начните с простых случаев (одна сеть)
   - Постепенно усложняйте (один NAT, два NAT)
   - Используйте tcpdump/Wireshark для анализа трафика

---

## Дополнительные ресурсы

- [RFC 3489: STUN](https://tools.ietf.org/html/rfc3489) - оригинальная спецификация STUN
- [Peer-to-Peer Communication Across Network Address Translators](http://www.brynosaurus.com/pub/net/p2pnat/) - оригинальная статья о NAT hole punching
- [Understanding NAT Types](https://www.ietf.org/rfc/rfc3489.txt) - типы NAT устройств

---

**Автор:** [Ваше имя]
**Дата:** 2025
**Версия:** 1.0



